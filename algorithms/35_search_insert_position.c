// https://leetcode.com/problems/search-insert-position/description/ 
/*
Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You must write an algorithm with O(log n) runtime complexity.



Example 1:

Input: nums = [1,3,5,6], target = 5
Output: 2

Example 2:

Input: nums = [1,3,5,6], target = 2
Output: 1

Example 3:

Input: nums = [1,3,5,6], target = 7
Output: 4


Constraints:
    1 <= nums.length <= 104
    -104 <= nums[i] <= 104
    nums contains distinct values sorted in ascending order.
    -104 <= target <= 104

*/ 
#include <stdio.h>

// Функция принимает:
// - указатель на начало массива целых чисел (int*)
// - размер массива (int)
// - искомое значение (int)
// Возвращает индекс, куда нужно вставить target, чтобы сохранить порядок.
int searchInsert(int* nums, int numsSize, int target) {
    // l_c и r_c — локальные переменные типа int.
    // В C переменные хранят **значения**, а не ссылки.
    // Они размещаются в стеке вызова функции (stack frame).
    int l_c = 0;                // Значение 0 записывается напрямую в память под l_c.
    int r_c = numsSize - 1;     // Аналогично: вычисляется выражение, результат кладётся в r_c.
    int mid;                    // Объявляем переменную без инициализации — её значение мусорное,
                                // но мы сразу присваиваем ей значение в цикле.

    // Цикл while: условие проверяется перед каждой итерацией.
    // Все операции происходят **непосредственно над значениями в регистрах или стеке**.
    while (l_c <= r_c) {
        // Вычисление середины без переполнения: mid = l_c + (r_c - l_c) / 2;
        // Это важно в C, потому что если бы мы писали (l_c + r_c) / 2,
        // то при больших значениях могло бы произойти целочисленное переполнение.
        mid = l_c + (r_c - l_c) / 2;

        // nums[mid] — это **прямой доступ к памяти**.
        // nums — это указатель (адрес первого элемента массива).
        // nums[mid] эквивалентно *(nums + mid): 
        //   - компилятор вычисляет адрес: nums + mid * sizeof(int)
        //   - читает 4 байта (на большинстве систем) из этой памяти как целое число.
        if (nums[mid] == target) {
            return mid;  // Возвращаем значение mid по значению (копия).
                         // Управление передаётся вызывающей функции, стековая рамка уничтожается.
        }
        else if (nums[mid] > target) {
            // Сдвигаем правую границу: просто меняем значение переменной r_c.
            // Никаких "объектов", "ссылок" или "структур" — только целое число в памяти.
            r_c = mid - 1;
        }
        else {
            // Аналогично: изменяем значение переменной l_c.
            l_c = mid + 1;
        }
        // В C нет автоматического управления памятью — всё, что выделено в стеке (как l_c, r_c, mid),
        // автоматически исчезает при выходе из функции.
    }

    // Если target не найден, возвращаем l_c.
    // Это корректный индекс для вставки, потому что в конце цикла l_c указывает на первую позицию,
    // где элемент >= target (или за концом массива).
    return l_c;
}

int main() {
    // Массив arr — это **фиксированный блок памяти в стеке**.
    // В отличие от Python-списка, это не объект с заголовком, ссылками и т.д.
    // Это просто 4 последовательных 4-байтовых слова (на x86-64): [1][3][5][6].
    int arr[] = {1, 3, 5, 6};

    // size — обычная переменная, хранящая число 4.
    // В Python len(list) — это метод, здесь же размер массива **неизвестен** внутри функции!
    // Поэтому мы явно передаём его как аргумент.
    int size = 4;

    int target = 0;

    // Вызов функции:
    // - arr при передаче **не копируется**.
    // - В C имя массива в выражении (arr) автоматически преобразуется в указатель на первый элемент.
    //   То есть фактически передаётся &arr[0] — адрес начала блока памяти.
    // - Это очень дёшево: всего 8 байт (размер указателя) вместо копирования всего массива.
    int result = searchInsert(arr, size, target);

    // printf — стандартная функция вывода.
    // %d ожидает 4-байтовое целое число (int), которое передаётся по значению через стек/регистры.
    printf("target index: %d\n", result);

    return 0;
}
// gcc 35_search_insert_position.c -o b_search